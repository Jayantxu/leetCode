*åŸé¢˜é“¾æ¥ï¼šğŸ‘‰ï¼š[æ‹¬å·ç”Ÿæˆ](https://leetcode-cn.com/problems/generate-parentheses/description/)*

é¢˜ç›®æè¿°:

1. æ•°å­— n ä»£è¡¨ç”Ÿæˆæ‹¬å·çš„å¯¹æ•°ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªå‡½æ•°ï¼Œç”¨äºèƒ½å¤Ÿç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¹¶ä¸” æœ‰æ•ˆçš„ æ‹¬å·ç»„åˆã€‚

ç¤ºä¾‹ï¼š

```
è¾“å…¥ï¼šn = 3
è¾“å‡ºï¼š["((()))","(()())","(())()","()(())","()()()"]
```

```
è¾“å…¥ï¼šn = 1
è¾“å‡ºï¼š["()"]
```

æ€è·¯ï¼š

> æ·±åº¦

```
var generateParenthesis = function(n) {
    // æ·±åº¦ï¼Œä½¿ç”¨ ) ä¹‹å‰å¿…é¡»ä¿è¯æ ˆå†…ä»æœ‰ ( æ‰å¯ä»¥ã€‚
    let leftUsed = 0,
        rightUsed = 0,
        leftWillUsed = n, rightWillUsed = n;
    let resArr = [];
    const matchBrack = (lU, rU, lWu, rWu, tempSTr) => {
        if(lU === n && rU === n) {
            resArr.push(tempSTr);
            return ;
        }
        if(lU > n || rU > n) return;
        if(rU > lU) {
            return;
        }
        if(lU === 0) {
            matchBrack(lU+1, rU, lWu-1, rWu, tempSTr+'(');
        } else {
            matchBrack(lU+1, rU, lWu-1, rWu, tempSTr+'(');
            matchBrack(lU, rU+1, lWu, rWu+1, tempSTr+')');
        }
    }
    matchBrack(leftUsed, rightUsed, leftWillUsed, rightWillUsed, '');
    return resArr;
};
```


- çœ‹é¢˜è§£ï¼Œè¿˜æ”¯æŒåŠ¨æ€è§„åˆ’.äº†è§£å­¦ä¹ ä¸€ä¸‹ã€‚